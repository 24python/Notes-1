# 模板方法模式

> 模板方法基于继承的代码复用,是一种类行为型模式

## 适用情景

  某些业务的实现需要多个流程,有些步骤是固定的,而有些是存在可变性的.(即: 步骤次序固定,存在公共代码)<br/>

  为了提高代码复用性和系统灵活性,可以将相同的步骤实现代码放在父类中,而对于存在可变性的方法,就只在父类中做一个声明,具体实现等待子类来完成,不同的子类可以有不同的实现方式.<br/>

## 优点

1. 父类中形式化地定义一个算法，而由它的子类来实现细节的处理，在子类实现详细的处理算法时并不会改变算法中步骤的执行次序

2. 提高代码的复用性

3. 利用面向对象的多态性,实现一种反向控制结构，通过子类覆盖父类的钩子方法来决定某一特定步骤是否需要执行

4. 通过子类来覆盖父类的基本方法，不同的子类可以提供基本方法的不同实现，更换和增加新的子类很方便，符合单一职责原则和开闭原则。

## 结构

1. 抽象父类:

类中定义了一系列基本方法对应每一个步骤,这些方法可以是抽象也可以是具体,子类可以重新定义,直接使用或实现这些方法.<br>
实现一个模板方法(调用了其他方法),用于定义一个算法框架(整个流程).

2. 具体子类:

用于覆盖父类中的具体方法或者实现抽象方法.

## 基本方法

+ 基本方法是模板方法的组成成分

1. 抽象方法:

由抽象父类声明,具体子类实现

2. 具体方法:

由抽象类声明,子类覆盖或者直接继承使用

3. 钩子方法:

一个钩子方法由一个抽象类或具体类声明并实现，而其子类可能会加以扩展。通常在父类中给出的实现是一个空实现，并以该空实现作为方法的默认实现.<br/>
当然钩子方法也可以提供一个非空的默认实现.<br/>

钩子方法有两类:

a. 与'实现步骤'挂钩,用于决定模板方法中的具体步骤,方法名一般为`iSXXX()`,对某个条件进行判断,以决定是否执行某步骤.<br/>
b. 实现体为空,子类可以选择覆盖或继承该钩子方法

## Java代码实现:




## 在以下情况下可以考虑使用模板方法模式：

(1) 对一些复杂的算法进行分割，将其算法中固定不变的部分设计为模板方法和父类具体方法，而一些可以改变的细节由其子类来实现。即：一次性实现一个算法的不变部分，并将可变的行为留给子类来实现。

(2) 各子类中公共的行为应被提取出来并集中到一个公共父类中以避免代码重复。

(3) 需要通过子类来决定父类算法中某个步骤是否执行，实现子类对父类的反向控制。
